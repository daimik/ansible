---
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ansible Playbook: Update all Docker containers (Watchtower-style)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
# Logic (mirrors Watchtower):
#   1. Discover all running containers and their current image digests
#   2. Pull ALL latest images upfront (slow part â€” no downtime yet)
#   3. Compare old vs new digests â€” build list of what actually changed
#   4. If NOTHING changed â†’ skip everything, send "all up to date" notification
#   5. Expand changed containers to full dependency groups
#   6. Collect run configs for containers that need recreating
#   7. Per group: fast stop(reverse) â†’ rm -f â†’ verify gone â†’ run(forward)
#   8. Verify, cleanup, notify
#
# Required extra-vars (set in Semaphore Environment):
#   gotify_url    - Gotify server URL (e.g. http://gotify/)
#   gotify_token  - Gotify application token

- name: Update all Docker containers
  hosts: all
  become: true
  gather_facts: true
  serial: 1

  vars:
    gotify_url: "{{ lookup('env', 'GOTIFY_URL') | default(gotify_url, true) }}"
    gotify_token: "{{ lookup('env', 'GOTIFY_TOKEN') | default(gotify_token, true) }}"
    gotify_priority: 5
    prune_old_images: true

    # Never touch these containers
    exclude_containers:
      - ansible-semaphoreui-1
      - ansible-semaphoreui_db-1

    # Dependency groups â€” if ANY member gets a new image, ALL are recreated.
    # Order = start order (DB first, then app, then sidecar).
    # Compose project groups are auto-detected from labels.
    manual_groups:
      zabbix-stack:
        - zabbix-postgres
        - zabbix-server
        - zabbix-web
        - zabbix-agent
        - zabbix-snmptraps
        - zabbix-smtp-gotify
      speedtest-stack:
        - speedtest-db
        - speedtest-web
      bookstack-stack:
        - bookstack_db
        - bookstack
      traccar-stack:
        - traccar
        - traccar-smtp-gotify

  tasks:
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 1. Discover running containers
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    - name: Get all running container names
      ansible.builtin.shell: >
        docker ps --filter "status=running" --format '{{ '{{' }}.Names{{ '}}' }}'
      register: _containers_raw
      changed_when: false

    - name: Build running containers list
      ansible.builtin.set_fact:
        _running: "{{ _containers_raw.stdout_lines | difference(exclude_containers) | sort }}"

    - name: Display running containers
      ansible.builtin.debug:
        msg: "{{ _running | length }} running containers ({{ exclude_containers | length }} excluded)"

    - name: End host if nothing running
      ansible.builtin.meta: end_host
      when: _running | length == 0

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 2. Deploy helper script
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    - name: Deploy helper script
      ansible.builtin.copy:
        dest: /tmp/duh.sh
        mode: "0755"
        content: |
          #!/bin/bash
          set -euo pipefail
          case "$1" in
            image-info)
              docker inspect --format '{{ '{{' }}.Config.Image{{ '}}' }}|{{ '{{' }}.Image{{ '}}' }}' "$2" | sed 's|^/||'
              ;;
            compose-project)
              docker inspect --format '{{ '{{' }}index .Config.Labels "com.docker.compose.project"{{ '}}' }}' "$2" 2>/dev/null || true
              ;;
            run-config)
              JSON=$(docker inspect "$2" 2>/dev/null)
              [ -z "$JSON" ] || [ "$JSON" = "[]" ] && { echo "empty inspect" >&2; exit 1; }
              echo "$JSON" | python3 -c '
          import sys, json

          c = json.loads(sys.stdin.read())[0]
          a = []

          a.append("--name " + c["Name"].lstrip("/"))

          for b in (c.get("HostConfig",{}).get("Binds") or []):
              a.append("-v " + b)

          for cp, binds in (c.get("HostConfig",{}).get("PortBindings") or {}).items():
              if binds:
                  for b in binds:
                      ip = b.get("HostIp","")
                      hp = b.get("HostPort","")
                      if ip and ip not in ("0.0.0.0","::",""):
                          a.append("-p {}:{}:{}".format(ip, hp, cp))
                      elif hp:
                          a.append("-p {}:{}".format(hp, cp))

          skip = ("PATH=","HOME=","TERM=","HOSTNAME=","PS1=",
                  "S6_CMD_WAIT","S6_VERBOSITY","S6_STAGE2",
                  "VIRTUAL_ENV=","PHP_INI_SCAN_DIR=","LSIO_FIRST_PARTY=",
                  "LANG=","LC_ALL=","LANGUAGE=","DEBIAN_FRONTEND=",
                  "GPG_KEY=","PYTHON_VERSION=","PYTHON_PIP_VERSION=",
                  "GOPATH=","GOSU_VERSION=","JAVA_HOME=",
                  "NODE_VERSION=","YARN_VERSION=","NPM_CONFIG",
                  "MYSQL_MAJOR=","MYSQL_VERSION=","MYSQL_SHELL",
                  "MARIADB_MAJOR=","MARIADB_VERSION=",
                  "PG_MAJOR=","PG_VERSION=","PG_SHA256=","PGDATA=",
                  "DOCKER_INFLUXDB","INFLUXDB_VERSION=",
                  "GF_PATHS","NGINX_VERSION=",
                  "ZBX_","MAPI_","TINI_VERSION=")
          for e in (c.get("Config",{}).get("Env") or []):
              if not any(e.startswith(p) for p in skip):
                  a.append("-e " + repr(e))

          rp = c.get("HostConfig",{}).get("RestartPolicy",{})
          rn = rp.get("Name","")
          if rn and rn != "no":
              mr = rp.get("MaximumRetryCount",0)
              if rn == "on-failure" and mr > 0:
                  a.append("--restart {}:{}".format(rn, mr))
              else:
                  a.append("--restart " + rn)

          net = c.get("HostConfig",{}).get("NetworkMode","")
          if net and net not in ("default","bridge"):
              a.append("--network " + net)

          if c.get("HostConfig",{}).get("Privileged"):
              a.append("--privileged")

          for d in (c.get("HostConfig",{}).get("Devices") or []):
              host_path = d["PathOnHost"]
              cont_path = d["PathInContainer"]
              a.append("--device {}:{}".format(host_path, cont_path))

          for cap in (c.get("HostConfig",{}).get("CapAdd") or []):
              a.append("--cap-add " + cap)

          pid = c.get("HostConfig",{}).get("PidMode","")
          if pid:
              a.append("--pid " + pid)

          skip_lp = ("com.docker.compose.","org.opencontainers.","desktop.docker.")
          for k,v in (c.get("Config",{}).get("Labels") or {}).items():
              if any(k.startswith(p) for p in skip_lp) or k == "maintainer":
                  continue
              a.append("-l " + repr(k + "=" + v))

          a.append("-d " + c["Config"]["Image"])

          cmd = c.get("Config",{}).get("Cmd")
          if cmd:
              a.append(" ".join(cmd))

          print(" ".join(a))
          '
              ;;
            status)
              docker ps --filter "name=^${2}$" --format '{{ '{{' }}.Status{{ '}}' }}'
              ;;
          esac

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 3. Snapshot current state (image + digest per container)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    - name: Get current image info
      ansible.builtin.command: /tmp/duh.sh image-info {{ item }}
      loop: "{{ _running }}"
      register: _img_info
      changed_when: false

    - name: Build image map
      ansible.builtin.set_fact:
        _img_map: >-
          {{ _img_map | default({}) | combine({
            item.item: {
              'image': item.stdout.split('|')[0],
              'digest': item.stdout.split('|')[1]
            }
          }) }}
      loop: "{{ _img_info.results }}"
      loop_control:
        label: "{{ item.item }}"

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 4. Pull ALL latest images upfront (no downtime yet)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    - name: Unique images to pull
      ansible.builtin.set_fact:
        _images: "{{ _img_map.values() | map(attribute='image') | unique | list }}"

    - name: "Pull {{ _images | length }} unique images"
      ansible.builtin.command: "docker pull {{ item }}"
      loop: "{{ _images }}"
      register: _pulls
      changed_when: false

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 5. Compare digests â€” what actually changed?
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    - name: Get new digests after pull
      ansible.builtin.shell: >
        docker image inspect {{ item.value.image }} --format '{{ '{{' }}.Id{{ '}}' }}'
      loop: "{{ _img_map | dict2items }}"
      register: _new_digests
      changed_when: false

    - name: Find containers with changed images
      ansible.builtin.set_fact:
        _changed: >-
          {{ _changed | default([]) +
            ([item.item.key] if item.stdout != _img_map[item.item.key].digest else [])
          }}
      loop: "{{ _new_digests.results }}"
      loop_control:
        label: "{{ item.item.key }}"

    - name: Default empty changed list
      ansible.builtin.set_fact:
        _changed: "{{ _changed | default([]) }}"

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 5a. NOTHING CHANGED â†’ skip to notification
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    - name: Nothing to update â€” skip to cleanup
      when: _changed | length == 0
      block:
        - name: Report all up to date
          ansible.builtin.debug:
            msg: "All {{ _running | length }} containers are already running latest images â€” nothing to do."

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 6. Build dependency groups & expand update list
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    - name: Detect compose projects
      ansible.builtin.command: /tmp/duh.sh compose-project {{ item }}
      loop: "{{ _running }}"
      register: _compose
      changed_when: false
      when: _changed | length > 0

    - name: Build groups and expand update list
      ansible.builtin.shell: |
        python3 << 'PYEOF'
        import json

        running = json.loads("""{{ _running | to_json }}""")
        changed = json.loads("""{{ _changed | to_json }}""")
        manual = json.loads("""{{ manual_groups | to_json }}""")
        compose_results = json.loads("""{{ _compose.results | default([]) | to_json }}""")

        # Map container -> group
        c2g = {}
        for r in compose_results:
            name = r.get("item", "")
            proj = (r.get("stdout") or "").strip()
            if proj:
                c2g[name] = "compose:" + proj
                continue
            # Check manual groups
            for gname, members in manual.items():
                if name in members:
                    c2g[name] = gname
                    break
            else:
                c2g[name] = "__standalone:" + name

        # Invert: group -> [containers] (preserving manual order)
        g2c = {}
        for container, group in c2g.items():
            g2c.setdefault(group, []).append(container)

        # Apply manual ordering where defined
        for gname in list(g2c.keys()):
            base = gname.replace("compose:", "")
            if base in manual:
                ordered = [c for c in manual[base] if c in g2c[gname]]
                extras = [c for c in g2c[gname] if c not in ordered]
                g2c[gname] = ordered + extras
            elif not gname.startswith("__standalone:"):
                g2c[gname] = sorted(g2c[gname])

        # Which groups are affected?
        affected_groups = list(set(c2g[c] for c in changed if c in c2g))

        # Expand: all containers in affected groups
        to_update = []
        for g in affected_groups:
            for c in g2c[g]:
                if c not in to_update:
                    to_update.append(c)

        result = {
            "container_group_map": c2g,
            "group_containers": g2c,
            "affected_groups": affected_groups,
            "to_update": to_update,
        }
        print(json.dumps(result))
        PYEOF
      register: _groups_raw
      changed_when: false
      when: _changed | length > 0

    - name: Set group facts
      ansible.builtin.set_fact:
        _g: "{{ _groups_raw.stdout | from_json }}"
      when: _changed | length > 0

    - name: Set empty group facts when nothing changed
      ansible.builtin.set_fact:
        _g:
          affected_groups: []
          to_update: []
          group_containers: {}
      when: _changed | length == 0

    - name: Display update plan
      ansible.builtin.debug:
        msg: >-
          {{ _changed | length }} image(s) changed: {{ _changed | join(', ') }}.
          {{ _g.affected_groups | length }} group(s) affected â†’
          {{ _g.to_update | length }} container(s) to recreate: {{ _g.to_update | join(', ') }}
      when: _changed | length > 0

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 7. Collect run configs BEFORE stopping anything
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    - name: Collect run configs (while containers still running)
      ansible.builtin.shell: /tmp/duh.sh run-config {{ item }}
      loop: "{{ _g.to_update }}"
      register: _configs
      changed_when: false
      when: _g.to_update | length > 0

    - name: Build config lookup
      ansible.builtin.set_fact:
        _cfg: >-
          {{ _cfg | default({}) | combine({ item.item: item.stdout | trim }) }}
      loop: "{{ _configs.results | default([]) }}"
      loop_control:
        label: "{{ item.item }}"
      when: _g.to_update | length > 0

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 8. Fast recreate per group (minimal downtime)
    #    Stop reverse â†’ rm -f â†’ verify gone â†’ run forward
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    - name: Recreate containers (group-aware, minimal downtime)
      ansible.builtin.shell: |
        python3 << 'PYEOF'
        import json, subprocess, sys, time

        affected = json.loads("""{{ _g.affected_groups | to_json }}""")
        g2c = json.loads("""{{ _g.group_containers | to_json }}""")
        to_update = json.loads("""{{ _g.to_update | to_json }}""")
        cfg = json.loads("""{{ _cfg | to_json }}""")

        ok, fail = [], []

        def run_cmd(cmd, shell=False):
            """Run a command and return (success, stderr)."""
            r = subprocess.run(cmd, shell=shell, capture_output=True, text=True)
            return r.returncode == 0, r.stderr.strip()

        def container_exists(name):
            """Check if container exists (running or stopped)."""
            r = subprocess.run(
                ["docker", "ps", "-a", "--filter", "name=^{}$".format(name), "--format", "{{{{.Names}}}}"],
                capture_output=True, text=True
            )
            return name in r.stdout.strip().split("\n")

        def force_remove(name):
            """Ensure container is fully removed. Returns True if gone."""
            # Try stop first (graceful 10s timeout)
            subprocess.run(["docker", "stop", "-t", "10", name],
                           capture_output=True, text=True)
            # Force remove (handles stopped, paused, dead states)
            subprocess.run(["docker", "rm", "-f", name],
                           capture_output=True, text=True)
            # Verify it is actually gone
            if container_exists(name):
                # Last resort: kill then rm
                subprocess.run(["docker", "kill", name],
                               capture_output=True, text=True)
                subprocess.run(["docker", "rm", "-f", name],
                               capture_output=True, text=True)
            return not container_exists(name)

        for group in affected:
            members = [c for c in g2c[group] if c in to_update]
            if not members:
                continue

            rev = list(reversed(members))
            print("=" * 60)
            print("  {}: {}".format(group, " -> ".join(members)))
            print("=" * 60)

            # â”€â”€ Stop & Remove (reverse order: dependents first) â”€â”€
            all_removed = True
            for c in rev:
                sys.stdout.write("  stop+rm {} ... ".format(c))
                sys.stdout.flush()
                if force_remove(c):
                    print("ok (gone)")
                else:
                    print("FAIL â€” container still exists!")
                    all_removed = False

            if not all_removed:
                print("  ERROR: could not remove all containers in group {}".format(group))
                fail.extend(members)
                continue

            # â”€â”€ Start (forward order: dependencies first) â”€â”€
            for c in members:
                conf = cfg.get(c)
                if not conf:
                    print("  ERROR: no run config for {}".format(c))
                    fail.append(c)
                    continue

                # Safety: ensure name is free before run
                if container_exists(c):
                    sys.stdout.write("  cleanup stale {} ... ".format(c))
                    sys.stdout.flush()
                    subprocess.run(["docker", "rm", "-f", c],
                                   capture_output=True, text=True)
                    print("ok")

                sys.stdout.write("  run   {} ... ".format(c))
                sys.stdout.flush()
                success, err = run_cmd("docker run " + conf, shell=True)
                if success:
                    print("ok")
                    ok.append(c)
                else:
                    print("FAIL: {}".format(err))
                    fail.append(c)

            # Brief stabilization pause between groups
            if group != affected[-1]:
                print("  ... waiting 5s between groups")
                time.sleep(5)

        print("=" * 60)
        print("  Done: {} ok, {} failed".format(len(ok), len(fail)))
        if fail:
            print("  FAILED: {}".format(", ".join(fail)))
            sys.exit(1)
        PYEOF
      register: _recreate
      changed_when: true
      when: _g.to_update | length > 0

    - name: Show recreate output
      ansible.builtin.debug:
        msg: "{{ _recreate.stdout_lines }}"
      when: _g.to_update | length > 0

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 9. Verify
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    - name: Verify containers are running
      ansible.builtin.command: /tmp/duh.sh status {{ item }}
      loop: "{{ _g.to_update }}"
      register: _verify
      failed_when: "'Up' not in _verify.stdout"
      changed_when: false
      when: _g.to_update | length > 0

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 10. Cleanup
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    - name: Docker cleanup
      when: prune_old_images
      block:
        - name: Prune dangling images
          ansible.builtin.command: docker image prune -f
          register: _prune_img
          changed_when: "'Total reclaimed space: 0B' not in _prune_img.stdout"

        - name: Prune unused volumes
          ansible.builtin.command: docker volume prune -f
          register: _prune_vol
          changed_when: "'Total reclaimed space: 0B' not in _prune_vol.stdout"

        - name: Prune unused networks
          ansible.builtin.command: docker network prune -f
          register: _prune_net
          changed_when: "'Deleted Networks' in _prune_net.stdout"

    - name: Remove helper script
      ansible.builtin.file:
        path: /tmp/duh.sh
        state: absent

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 11. Gotify notification
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    - name: Ensure curl is installed
      ansible.builtin.apt:
        name: curl
        state: present

    - name: Build notification
      ansible.builtin.set_fact:
        _ntfy_title: >-
          {{ 'ðŸ³ ' + ansible_hostname + ' â€” ' +
             (_changed | length | string) + ' updated, ' +
             (_g.to_update | length | string) + ' recreated'
             if _g.to_update | length > 0
             else 'ðŸ³ ' + ansible_hostname + ' â€” All up to date' }}
        _ntfy_body: >-
          ðŸ–¥ï¸ **Host:** {{ ansible_hostname }} ({{ ansible_default_ipv4.address }})\n\nðŸ³
          **Running:** {{ _running | length }}\n\nðŸ“¦
          **New images:** {{ _changed | length }}\n\nðŸ”„
          **Recreated:** {{ _g.to_update | length }}\n\n{{
          'ðŸ†• **Changed:** ' + _changed | join(', ') + '\n\n'
          if _changed | length > 0 else '' }}{{
          'ðŸ”— **Groups:** ' + _g.affected_groups | join(', ') + '\n\n'
          if _g.affected_groups | length > 0 else '' }}{{
          'â™»ï¸ **Recreated:** ' + _g.to_update | join(', ') + '\n\n'
          if _g.to_update | length > 0 else '' }}---\n\n{{
          'âœ… All containers recreated and verified'
          if _g.to_update | length > 0
          else 'âœ… All images already latest' }}
        _ntfy_prio: "{{ 6 if _g.to_update | length > 0 else gotify_priority }}"

    - name: Send Gotify notification
      ansible.builtin.shell: |
        cat <<'PAYLOAD' | curl -s -m 15 -o /dev/null -w "%{http_code}" \
          -X POST "{{ gotify_url }}message" \
          -H "X-Gotify-Key: {{ gotify_token }}" \
          -H "Content-Type: application/json" \
          -d @-
        {
          "title": "{{ _ntfy_title | trim }}",
          "message": "{{ _ntfy_body | trim }}",
          "priority": {{ _ntfy_prio }},
          "extras": {"client::display": {"contentType": "text/markdown"}}
        }
        PAYLOAD
      register: _gotify
      changed_when: false
      failed_when: _gotify.stdout != "200"

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 12. Summary
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    - name: Final status
      ansible.builtin.debug:
        msg:
          - "Host: {{ ansible_hostname }} ({{ inventory_hostname }})"
          - "Containers: {{ _running | length }} running, {{ exclude_containers | length }} excluded"
          - "Images changed: {{ _changed | length }} â€” {{ _changed | join(', ') if _changed | length > 0 else 'None' }}"
          - "Groups affected: {{ _g.affected_groups | join(', ') if _g.affected_groups | length > 0 else 'None' }}"
          - "Recreated: {{ _g.to_update | length }} â€” {{ _g.to_update | join(', ') if _g.to_update | length > 0 else 'None' }}"
          - "Cleanup: images={{ 'yes' if _prune_img.changed | default(false) else 'no' }} volumes={{ 'yes' if _prune_vol.changed | default(false) else 'no' }} networks={{ 'yes' if _prune_net.changed | default(false) else 'no' }}"
