---
# Update order: Core -> Supervisor -> OS
# Core and Supervisor don't reboot, OS does.
# Each update waits for HA to be fully available before proceeding.
# If any update fails, the playbook stops - no further updates are attempted.
# After updates, old backups are pruned to keep only the last 3.
#
# Required extra-vars (set in Semaphore Environment):
#   ha_url         - Home Assistant URL (e.g. http://homeassistan.com)
#   vault_ha_token - Home Assistant long-lived access token
#   gotify_url     - Gotify server URL (e.g. http://gotify)
#   gotify_token   - Gotify application token

- name: Update Home Assistant
  hosts: homeassistant
  gather_facts: false
  serial: 1
  max_fail_percentage: 0

  vars:
    gotify_url: "{{ lookup('env', 'GOTIFY_URL') | default(gotify_url, true) }}"
    gotify_token: "{{ lookup('env', 'GOTIFY_TOKEN') | default(gotify_token, true) }}"
    gotify_priority: 5
    backups_to_keep: 3

  tasks:
    # -------------------------------------------------------
    # Phase 1: Check current state of all components
    # -------------------------------------------------------
    - name: Check HA API is reachable
      ansible.builtin.uri:
        url: "{{ ha_url }}/api/"
        method: GET
        headers:
          Authorization: "Bearer {{ vault_ha_token }}"
        return_content: true
        status_code: 200

    - name: Get Core update status
      ansible.builtin.uri:
        url: "{{ ha_url }}/api/states/update.home_assistant_core_update"
        method: GET
        headers:
          Authorization: "Bearer {{ vault_ha_token }}"
        return_content: true
        status_code: 200
      register: core_update

    - name: Get Supervisor update status
      ansible.builtin.uri:
        url: "{{ ha_url }}/api/states/update.home_assistant_supervisor_update"
        method: GET
        headers:
          Authorization: "Bearer {{ vault_ha_token }}"
        return_content: true
        status_code: 200
      register: supervisor_update

    - name: Get OS update status
      ansible.builtin.uri:
        url: "{{ ha_url }}/api/states/update.home_assistant_operating_system_update"
        method: GET
        headers:
          Authorization: "Bearer {{ vault_ha_token }}"
        return_content: true
        status_code: 200
      register: os_update

    - name: Set update flags
      ansible.builtin.set_fact:
        core_needs_update: "{{ core_update.json.state == 'on' }}"
        supervisor_needs_update: "{{ supervisor_update.json.state == 'on' }}"
        os_needs_update: "{{ os_update.json.state == 'on' }}"
        any_update_available: "{{ core_update.json.state == 'on' or supervisor_update.json.state == 'on' or os_update.json.state == 'on' }}"

    - name: Display version overview
      ansible.builtin.debug:
        msg: |
          === Current Status ===
          Core:       {{ core_update.json.attributes.installed_version }} -> {{ core_update.json.attributes.latest_version }} {{ '[UPDATE AVAILABLE]' if core_needs_update else '[OK]' }}
          Supervisor: {{ supervisor_update.json.attributes.installed_version }} -> {{ supervisor_update.json.attributes.latest_version }} {{ '[UPDATE AVAILABLE]' if supervisor_needs_update else '[OK]' }}
          OS:         {{ os_update.json.attributes.installed_version }} -> {{ os_update.json.attributes.latest_version }} {{ '[UPDATE AVAILABLE]' if os_needs_update else '[OK]' }}

    - name: No updates available
      ansible.builtin.debug:
        msg: "All components are up to date. Nothing to do."
      when: not any_update_available

    # -------------------------------------------------------
    # Notify: No updates available
    # -------------------------------------------------------
    - name: Send Gotify notification (no updates)
      ansible.builtin.shell: |
        cat <<'PAYLOAD' | curl -s -o /dev/null -w "%{http_code}" \
          -X POST "{{ gotify_url }}message" \
          -H "X-Gotify-Key: {{ gotify_token }}" \
          -H "Content-Type: application/json" \
          -d @-
        {
          "title": "âœ… Home Assistant â€” Already up to date",
          "message": "ðŸ  **Home Assistant**\n\nðŸŸ¢ **Core:** {{ core_update.json.attributes.installed_version }}\n\nðŸŸ¢ **Supervisor:** {{ supervisor_update.json.attributes.installed_version }}\n\nðŸŸ¢ **OS:** {{ os_update.json.attributes.installed_version }}\n\n---\n\nâœ… **All components are up to date**",
          "priority": {{ gotify_priority }},
          "extras": {"client::display": {"contentType": "text/markdown"}}
        }
        PAYLOAD
      delegate_to: localhost
      changed_when: false
      when: not any_update_available

    # -------------------------------------------------------
    # Phase 2: Backup via hassio service
    # -------------------------------------------------------
    - name: Create full backup before updating
      ansible.builtin.uri:
        url: "{{ ha_url }}/api/services/hassio/backup_full"
        method: POST
        headers:
          Authorization: "Bearer {{ vault_ha_token }}"
          Content-Type: "application/json"
        body_format: json
        body:
          name: "ansible-pre-update-{{ lookup('pipe', 'date +%Y%m%d-%H%M%S') }}"
        status_code: [200, 201]
        timeout: 600
      when: any_update_available

    - name: Wait for backup to complete
      ansible.builtin.pause:
        seconds: 120
      when: any_update_available

    # -------------------------------------------------------
    # Phase 3: Update Core (no reboot, but HA restarts)
    # The update call may drop the connection when HA restarts
    # itself, so we accept connection failures and verify after.
    # -------------------------------------------------------
    - name: "Update Core: {{ core_update.json.attributes.installed_version }} -> {{ core_update.json.attributes.latest_version }}"
      ansible.builtin.uri:
        url: "{{ ha_url }}/api/services/update/install"
        method: POST
        headers:
          Authorization: "Bearer {{ vault_ha_token }}"
          Content-Type: "application/json"
        body_format: json
        body:
          entity_id: "update.home_assistant_core_update"
        status_code: [200, 201]
        timeout: 300
      register: core_update_result
      failed_when: >
        core_update_result is failed
        and 'Remote end closed connection' not in (core_update_result.msg | default(''))
        and 'Connection failure' not in (core_update_result.msg | default(''))
        and 'timed out' not in (core_update_result.msg | default(''))
      when: core_needs_update

    - name: Wait for HA to restart after Core update
      ansible.builtin.uri:
        url: "{{ ha_url }}/api/"
        method: GET
        headers:
          Authorization: "Bearer {{ vault_ha_token }}"
        status_code: 200
      register: ha_health_core
      until: ha_health_core.status == 200
      retries: 60
      delay: 10
      when: core_needs_update

    - name: Verify Core update completed
      ansible.builtin.uri:
        url: "{{ ha_url }}/api/states/update.home_assistant_core_update"
        method: GET
        headers:
          Authorization: "Bearer {{ vault_ha_token }}"
        return_content: true
        status_code: 200
      register: core_verify
      when: core_needs_update

    - name: Confirm Core is updated
      ansible.builtin.assert:
        that:
          - core_verify.json.attributes.installed_version == core_update.json.attributes.latest_version
        fail_msg: "Core update failed! Installed: {{ core_verify.json.attributes.installed_version }}, Expected: {{ core_update.json.attributes.latest_version }}. Stopping."
        success_msg: "Core successfully updated to {{ core_verify.json.attributes.installed_version }}"
      when: core_needs_update

    # -------------------------------------------------------
    # Phase 4: Update Supervisor (no reboot)
    # -------------------------------------------------------
    - name: "Update Supervisor: {{ supervisor_update.json.attributes.installed_version }} -> {{ supervisor_update.json.attributes.latest_version }}"
      ansible.builtin.uri:
        url: "{{ ha_url }}/api/services/update/install"
        method: POST
        headers:
          Authorization: "Bearer {{ vault_ha_token }}"
          Content-Type: "application/json"
        body_format: json
        body:
          entity_id: "update.home_assistant_supervisor_update"
        status_code: [200, 201]
        timeout: 300
      register: supervisor_update_result
      failed_when: >
        supervisor_update_result is failed
        and 'Remote end closed connection' not in (supervisor_update_result.msg | default(''))
        and 'Connection failure' not in (supervisor_update_result.msg | default(''))
        and 'timed out' not in (supervisor_update_result.msg | default(''))
      when: supervisor_needs_update

    - name: Wait for HA after Supervisor update
      ansible.builtin.uri:
        url: "{{ ha_url }}/api/"
        method: GET
        headers:
          Authorization: "Bearer {{ vault_ha_token }}"
        status_code: 200
      register: ha_health_sup
      until: ha_health_sup.status == 200
      retries: 60
      delay: 10
      when: supervisor_needs_update

    # -------------------------------------------------------
    # Phase 5: Update OS (REBOOTS the machine!)
    # -------------------------------------------------------
    - name: "Update OS: {{ os_update.json.attributes.installed_version }} -> {{ os_update.json.attributes.latest_version }} (WILL REBOOT)"
      ansible.builtin.uri:
        url: "{{ ha_url }}/api/services/update/install"
        method: POST
        headers:
          Authorization: "Bearer {{ vault_ha_token }}"
          Content-Type: "application/json"
        body_format: json
        body:
          entity_id: "update.home_assistant_operating_system_update"
        status_code: [200, 201]
        timeout: 300
      register: os_update_result
      failed_when: >
        os_update_result is failed
        and 'Remote end closed connection' not in (os_update_result.msg | default(''))
        and 'Connection failure' not in (os_update_result.msg | default(''))
        and 'timed out' not in (os_update_result.msg | default(''))
      when: os_needs_update

    - name: Wait for system to reboot after OS update (longer wait)
      ansible.builtin.pause:
        seconds: 60
      when: os_needs_update

    - name: Wait for HA to come back after OS reboot
      ansible.builtin.uri:
        url: "{{ ha_url }}/api/"
        method: GET
        headers:
          Authorization: "Bearer {{ vault_ha_token }}"
        status_code: 200
      register: ha_health_os
      until: ha_health_os.status == 200
      retries: 90
      delay: 15
      when: os_needs_update

    # -------------------------------------------------------
    # Phase 6: Backup retention â€” keep only last N backups
    # Uses POST /api/template to list backups (works with
    # Bearer token), and hassio.backup_remove to delete.
    # -------------------------------------------------------
    - name: Get backup list via template API
      ansible.builtin.uri:
        url: "{{ ha_url }}/api/template"
        method: POST
        headers:
          Authorization: "Bearer {{ vault_ha_token }}"
          Content-Type: "application/json"
        body_format: json
        body:
          template: >-
            {{ '{{' }} state_attr('sensor.backup_manager', 'backups')
            | default([], true)
            | sort(attribute='date', reverse=true)
            | map(attribute='slug')
            | list
            | tojson {{ '}}' }}
        return_content: true
        status_code: 200
      register: backup_slugs_raw
      ignore_errors: true

    # Fallback: get backup info from the backup sensor state attributes
    - name: Get backup info from sensor attributes
      ansible.builtin.uri:
        url: "{{ ha_url }}/api/states/sensor.backup_manager"
        method: GET
        headers:
          Authorization: "Bearer {{ vault_ha_token }}"
        return_content: true
        status_code: [200, 404]
      register: backup_sensor
      when: backup_slugs_raw is failed
      ignore_errors: true

    # Fallback 2: list all sensor entities to find the right backup sensor
    - name: Get backup state sensor
      ansible.builtin.uri:
        url: "{{ ha_url }}/api/states/sensor.backup_state"
        method: GET
        headers:
          Authorization: "Bearer {{ vault_ha_token }}"
        return_content: true
        status_code: [200, 404]
      register: backup_state_sensor
      when: backup_slugs_raw is failed
      ignore_errors: true

    # Fallback 3: Try hassio backups info endpoint (sometimes works)
    - name: Try Supervisor backup list
      ansible.builtin.uri:
        url: "{{ ha_url }}/api/hassio/backups/info"
        method: GET
        headers:
          Authorization: "Bearer {{ vault_ha_token }}"
        return_content: true
        status_code: [200, 401]
      register: backup_list_hassio
      ignore_errors: true

    - name: Debug - show what backup data we got
      ansible.builtin.debug:
        msg: |
          === Backup Data Sources Debug ===
          Template API success: {{ backup_slugs_raw is succeeded }}
          {% if backup_slugs_raw is succeeded %}
          Template result: {{ backup_slugs_raw.content[:500] | default('empty') }}
          {% endif %}
          Backup manager sensor status: {{ backup_sensor.status | default('skipped') }}
          {% if backup_sensor is defined and backup_sensor is succeeded and backup_sensor.status == 200 %}
          Backup manager keys: {{ backup_sensor.json.attributes.keys() | list | default([]) }}
          {% endif %}
          Backup state sensor status: {{ backup_state_sensor.status | default('skipped') }}
          {% if backup_state_sensor is defined and backup_state_sensor is succeeded and backup_state_sensor.status == 200 %}
          Backup state keys: {{ backup_state_sensor.json.attributes.keys() | list | default([]) }}
          {% endif %}
          Hassio backups info status: {{ backup_list_hassio.status | default('skipped') }}
          {% if backup_list_hassio is defined and backup_list_hassio is succeeded and backup_list_hassio.status == 200 %}
          Hassio response keys: {{ backup_list_hassio.json.keys() | list | default([]) }}
          Hassio content (first 500): {{ backup_list_hassio.content[:500] | default('empty') }}
          {% endif %}

    # Parse from whichever source worked
    - name: Parse backup list
      ansible.builtin.set_fact:
        all_backups: >-
          {%- if backup_list_hassio is defined and backup_list_hassio is succeeded and backup_list_hassio.status == 200 -%}
            {%- if backup_list_hassio.json.data is defined and backup_list_hassio.json.data.backups is defined -%}
              {{ backup_list_hassio.json.data.backups }}
            {%- elif backup_list_hassio.json.backups is defined -%}
              {{ backup_list_hassio.json.backups }}
            {%- else -%}
              []
            {%- endif -%}
          {%- elif backup_sensor is defined and backup_sensor is succeeded and backup_sensor.status == 200 and backup_sensor.json.attributes.backups is defined -%}
            {{ backup_sensor.json.attributes.backups }}
          {%- else -%}
            []
          {%- endif -%}

    - name: Sort backups and determine which to delete
      ansible.builtin.set_fact:
        backups_sorted: "{{ all_backups | sort(attribute='date') | reverse | list }}"

    - name: Set backups to remove
      ansible.builtin.set_fact:
        backups_to_remove: "{{ backups_sorted[backups_to_keep:] | default([]) }}"
        backups_kept_count: "{{ [backups_sorted | length, backups_to_keep] | min }}"

    - name: Display backup retention plan
      ansible.builtin.debug:
        msg: |
          === Backup Retention ===
          Total backups found: {{ backups_sorted | length }}
          Keeping: {{ backups_kept_count }}
          Deleting: {{ backups_to_remove | length }}
          {% for b in backups_sorted[:backups_to_keep | int] %}
          âœ… KEEP: {{ b.name | default(b.slug) }} ({{ b.date }})
          {% endfor %}
          {% for b in backups_to_remove %}
          ðŸ—‘ï¸ DELETE: {{ b.name | default(b.slug) }} ({{ b.date }})
          {% endfor %}
          {{ 'âœ… No old backups to remove' if backups_to_remove | length == 0 else '' }}

    - name: Delete old backups via hassio service
      ansible.builtin.uri:
        url: "{{ ha_url }}/api/services/hassio/backup_remove"
        method: POST
        headers:
          Authorization: "Bearer {{ vault_ha_token }}"
          Content-Type: "application/json"
        body_format: json
        body:
          slug: "{{ item.slug }}"
        status_code: [200, 201]
      loop: "{{ backups_to_remove }}"
      loop_control:
        label: "{{ item.name | default(item.slug) }} ({{ item.date }})"
      when: backups_to_remove | length > 0
      ignore_errors: true

    # -------------------------------------------------------
    # Phase 7: Final summary
    # -------------------------------------------------------
    - name: Update summary
      ansible.builtin.debug:
        msg: |
          === Update Summary ===
          Core:       {{ 'Updated to ' + core_update.json.attributes.latest_version if core_needs_update else 'Already up to date (' + core_update.json.attributes.installed_version + ')' }}
          Supervisor: {{ 'Updated to ' + supervisor_update.json.attributes.latest_version if supervisor_needs_update else 'Already up to date (' + supervisor_update.json.attributes.installed_version + ')' }}
          OS:         {{ 'Updated to ' + os_update.json.attributes.latest_version if os_needs_update else 'Already up to date (' + os_update.json.attributes.installed_version + ')' }}
          Backups:    {{ backups_to_remove | length }} old backup(s) removed, {{ backups_kept_count }} retained

    # -------------------------------------------------------
    # Phase 8: Gotify notification (updates were performed)
    # -------------------------------------------------------
    - name: Send Gotify notification (updates completed)
      ansible.builtin.shell: |
        cat <<'PAYLOAD' | curl -s -o /dev/null -w "%{http_code}" \
          -X POST "{{ gotify_url }}message" \
          -H "X-Gotify-Key: {{ gotify_token }}" \
          -H "Content-Type: application/json" \
          -d @-
        {
          "title": "ðŸ  Home Assistant â€” Updated successfully",
          "message": "ðŸ  **Home Assistant**\n\nðŸ”§ **Core:** {{ core_update.json.attributes.installed_version }} â†’ {{ core_update.json.attributes.latest_version }} {{ 'âœ… Updated' if core_needs_update else 'â€” No change' }}\n\nðŸ”§ **Supervisor:** {{ supervisor_update.json.attributes.installed_version }} â†’ {{ supervisor_update.json.attributes.latest_version }} {{ 'âœ… Updated' if supervisor_needs_update else 'â€” No change' }}\n\nðŸ”§ **OS:** {{ os_update.json.attributes.installed_version }} â†’ {{ os_update.json.attributes.latest_version }} {{ 'âœ… Updated' if os_needs_update else 'â€” No change' }}\n\nðŸ—‘ï¸ **Backups:** {{ backups_to_remove | length }} removed, {{ backups_kept_count }} kept\n\n---\n\n{{ 'ðŸ”„ **OS was updated â€” system rebooted**' if os_needs_update else 'âœ… **All updates applied â€” no reboot needed**' }}",
          "priority": {{ 8 if os_needs_update else gotify_priority }},
          "extras": {"client::display": {"contentType": "text/markdown"}}
        }
        PAYLOAD
      delegate_to: localhost
      changed_when: false
      when: any_update_available
